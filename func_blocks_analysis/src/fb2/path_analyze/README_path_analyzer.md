# Документация: Анализатор маршрутов пользователей

## Описание

Скрипт `path_analyzer.py` анализирует пути пользователей от начала сессии до целевых действий (success_review и success_actions) в мобильном приложении МКД.

## Возможности

1. **Автоматический анализ путей** - для всех целевых действий из categorized_combinations.json
2. **TOP-5 маршрутов** - для каждого целевого действия
3. **Умное сжатие путей** - если >3 различных действий с одинаковым Экран+Функционал, сворачивается в "[N действий]"
4. **Гибкое использование** - можно запускать как из командной строки, так и импортировать как модуль

## Требования к данным

### Входной датасет (CSV)
Обязательные колонки:
- `Дата и время события` - временная метка
- `Экран` - название экрана
- `Функционал` - функционал/действие
- `Действие` - описание действия
- `global_session_id` - уникальный ID сессии

### Файл категоризации (JSON)
Формат: `categorized_combinations_v2.json`

Структура:
```json
{
  "blocks": [
    {
      "name": "Название блока",
      "groups": [
        {
          "screen": "Экран",
          "functional": "Функционал",
          "success_review": [...],
          "success_actions": [...]
        }
      ]
    }
  ]
}
```

## Использование

### Способ 1: Простой (одна функция)

```python
from path_analyzer import analyze_paths

analyze_paths(
    dataset_path='data.csv',
    categorization_path='categorized_combinations_v2.json',
    output_path='path_analysis.txt'
)
```

### Способ 2: Через класс

```python
from path_analyzer import PathAnalyzer

analyzer = PathAnalyzer(
    dataset_path='data.csv',
    categorization_path='categorized_combinations_v2.json'
)

analyzer.load_data()
results = analyzer.analyze_all_blocks()
analyzer.export_to_text(results, 'path_analysis.txt')
```

### Способ 3: Анализ конкретного действия

```python
from path_analyzer import PathAnalyzer

analyzer = PathAnalyzer('data.csv', 'categorized_combinations_v2.json')
analyzer.load_data()

# Поиск путей к конкретному действию
paths = analyzer.find_paths_to_action(
    target_screen='Новая заявка',
    target_functional='Отправка заявки',
    target_action="Тап на кнопку 'Создать заявку'"
)

# Вывод TOP-10
for rank, (path, count) in enumerate(paths.most_common(10), 1):
    print(f"{rank}. {count} раз")
    print(f"   {path}")
```

### Запуск из командной строки

```bash
python3 path_analyzer.py
```

## Логика работы

### 1. Извлечение пути

Для каждой сессии, где встречается целевое действие:
1. Сортировка записей по времени
2. Извлечение всех шагов от начала сессии до целевого действия
3. Формирование последовательности: [(Экран, Функционал, Действие), ...]

### 2. Сжатие пути

Если в последовательности встречаются одинаковые (Экран, Функционал) с >3 различными Действиями:

**Было:**
```
Новая заявка => Выбор актуальной темы => Некачественное содержание лифта
Новая заявка => Выбор актуальной темы => Неубранный подъезд
Новая заявка => Выбор актуальной темы => Отсутствие отопления
Новая заявка => Выбор актуальной темы => Неисправность двери
```

**Стало:**
```
Новая заявка => Выбор актуальной темы => [4 действий]
```

### 3. Подсчёт частоты

Подсчитывается, сколько раз встречается каждый уникальный путь.

### 4. Формирование TOP-5

Выбираются 5 самых частых путей для каждого целевого действия.

## Формат выходного файла

```
================================================================================
АНАЛИЗ МАРШРУТОВ ДО ЦЕЛЕВЫХ ДЕЙСТВИЙ
================================================================================
Всего блоков с целевыми действиями: 12
Дата анализа: 2025-12-23T...
================================================================================

Создание заявки (595,534):

  [success_actions] Новая заявка => Отправка заявки => Тап на кнопку 'Создать заявку' (45,221):
    TOP-5 маршрутов:

    1. Частота: 15,234 (33.7%)
       Маршрут:
        Еще => Переход в раздел 'Заявки' => Тап на кнопку 'Заявки'
        Новая заявка => Открытие экрана => Не указано
        Новая заявка => Выбор актуальной темы => [192 действий]
        Новая заявка => Отправка заявки => Тап на кнопку 'Создать заявку'

    2. Частота: 8,456 (18.7%)
       Маршрут:
        Еще => Переход в раздел 'Заявки' => Тап на кнопку 'Заявки'
        Новая заявка => Открытие экрана => Не указано
        Новая заявка => Выбор через теги => Выбор тега 1
        Новая заявка => Выбор актуальной темы => [192 действий]
        Новая заявка => Отправка заявки => Тап на кнопку 'Создать заявку'

    ...

================================================================================
```

## Интерпретация результатов

### Анализ конверсии

```
Частота: 15,234 (33.7%)
```
- 15,234 пользователей прошли этим путём
- Это 33.7% от всех, кто достиг целевого действия

### Анализ воронки

Путь показывает последовательность шагов:
1. Вход через раздел "Заявки"
2. Открытие формы создания заявки
3. Выбор темы (множество вариантов)
4. Отправка заявки

### Оптимизация UX

**Если много шагов в пути** → упростить процесс
**Если частое сворачивание "[N действий]"** → оптимизировать выбор
**Если низкая частота TOP-1** → нет доминирующего пути, разброс сценариев

## Примеры анализа

### Пример 1: Простой путь

```
TOP-1 маршрут (85%):
  Важное => Просмотр уведомления => Тап на уведомление
```
**Вывод**: Прямой путь, высокая конверсия

### Пример 2: Сложный путь

```
TOP-1 маршрут (25%):
  Еще => Переход в раздел 'Заявки' => Тап на кнопку 'Заявки'
  Новая заявка => Открытие экрана => Не указано
  Новая заявка => Выбор через теги => [128 действий]
  Новая заявка => Выбор актуальной темы => [192 действий]
  Новая заявка => Отправка заявки => Тап на кнопку 'Создать заявку'
```
**Вывод**: 
- Множество вариантов выбора темы (320 комбинаций)
- Низкая доля TOP-1 пути (25%) → высокое разнообразие
- Возможно, стоит упростить выбор темы

### Пример 3: Анализ оттока

Сравните пути до success_actions и cancel_actions:
```
Success: Еще → Новая заявка → Выбор темы → Отправка (45,221)
Cancel:  Еще → Новая заявка → Возврат назад (102,203)
```
**Вывод**: Высокий отток на этапе после открытия формы

## Производительность

### Оценка времени выполнения

| Размер датасета | Время выполнения | Памяти |
|-----------------|------------------|--------|
| 1M записей      | ~5-10 минут     | ~500MB |
| 2M записей      | ~10-20 минут    | ~1GB   |
| 5M записей      | ~30-60 минут    | ~2.5GB |

### Оптимизация

Для больших датасетов:
1. Анализируйте только нужные блоки
2. Ограничьте количество путей (TOP-3 вместо TOP-5)
3. Используйте фильтрацию по датам

## Ограничения

1. **Требуется global_session_id** - данные должны быть предобработаны
2. **Анализ только от начала сессии** - не учитываются предыдущие сессии пользователя
3. **Память** - весь датасет загружается в память

## Расширение функциональности

### Добавление фильтров

```python
# Фильтрация по периоду
analyzer.df = analyzer.df[
    (analyzer.df['date'] >= '2025-09-01') & 
    (analyzer.df['date'] <= '2025-09-30')
]

# Фильтрация по устройствам
analyzer.df = analyzer.df[analyzer.df['ОС'] == 'Android']

# Фильтрация по возрастной группе
analyzer.df = analyzer.df[analyzer.df['age_group'] == '35-44']
```

### Анализ промежуточных путей

```python
# Пути от конкретного экрана до целевого действия
def find_paths_from_screen(analyzer, start_screen, target_screen, target_functional, target_action):
    """Находит пути, начинающиеся с определённого экрана."""
    paths = analyzer.find_paths_to_action(target_screen, target_functional, target_action)
    
    # Фильтруем только пути, начинающиеся с start_screen
    filtered = Counter()
    for path_str, count in paths.items():
        if path_str.startswith(start_screen):
            filtered[path_str] = count
    
    return filtered
```

## Файлы проекта

- `path_analyzer.py` - основной скрипт
- `example_path_analysis.py` - примеры использования
- `README_path_analyzer.md` - этот файл

## Техническая поддержка

При возникновении ошибок проверьте:
1. Наличие колонки `global_session_id` в датасете
2. Корректность формата `categorized_combinations_v2.json`
3. Достаточность памяти для загрузки датасета

---
**Версия**: 1.0
**Дата**: 2025-12-23
**Автор**: Claude (Anthropic)
